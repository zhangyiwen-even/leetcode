echo "# leetcode" >> README.md
git init  # 新建目录/初始化本地目录
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:zhangyiwen-even/leetcode.git
git push -u origin main
                
…or push an existing repository from the command line
git remote add origin git@github.com:zhangyiwen-even/leetcode.git
git branch -M main
git push -u origin main


朱双印 git命令相关的笔记
# 配置全局
git config --global user.name "zhangyiwen-even"
git config --global user.email "1440590368@qq.com"

# 列出所有配置项
git config --global --list
git config --system --list
git config --local --list

# 初始化名为test的git仓库
git init test
# 进入test仓库
cd test
# 创建两个测试文件
echo f1 > file1
echo f2 > file2

# 查看哪些文件状态有变更
git status  
untracked files 表示创建的文件都是新加入工作目录的文件，即“未被跟踪”的文件
# 追踪两个文件，将文件转化为git对象
git add file1
git add file2


git status:查看有没有变更的状态，并且查看哪些变更已经加入了暂存区，红色的变更表示只存在于工作区，还未加入暂存区，绿色的变更表示已经加入到暂存区，这些变更将会被提交。
git add:将需要进行提交的变更加入到暂存区。
git commit:将所有加入暂存区的变更作为一个变更集合，创建提交。
git log:查看提交历史，此命令有很多实用参数可以使用，利用这些参数可以通过不同的方式查看历史
git log --oneline：查看提交历史，结果只有1行，显示哈希码和文件内容，哈希码只显示前面几位

git cat-file -t 哈希值:查看对象的类型（是不是commit等）
git cat-file -p 哈希值:查看对象的内容
# 禁用自动转换换行符
git config --global core.autocrlf false  
git reset --hard 哈希值：版本回退到执行的哈希值的位置
git reflog：记录各种指针的常见操作。回退后，要想回滚到最新一次提交，可以使用此命令获取最近几次提交的哈希码做以回滚
git branch：查看当前处于哪个分支，前面会显示一个星号*
git branch -v：查看更详细的分支信息
git branch -vv：查看更详细的分支信息
git branch test：基于master分支创建新分支test，但不会切换当前分支，test分支和master分支完全相同
git checkout test：切换到新分支test
git checkout -b test:创建并切换到test分支
git log --oneline --all --graph：在命令行中以字符的形式尽量接近图形化的方式展示分支
git checkout 哈希值：进入哈希值对应的分离头状态
git checkout -b newtest：保存分离头为一个新分支（给分离头状态下产生的匿名分支命名）
git branch newtest 哈希值：创建一个newtest的分支保存分离头状态下创建的提交
git diff：比较工作区文件和暂存区的区别
git diff -- test1:查看test1文件工作区和暂存区的区别
git diff HEAD：查看工作区和最新提交之间的差异
等于
git diff 最新提交的哈希码：查看工作区和最新提交之间的差异
当暂存区和提交中的状态是完全相同的时，git diff和git diff HEAD的返回结果是相同的
git add -A：将所有修改添加到暂存区
git diff --cached：查看暂存区和最新提交的差异
git diff 哈希值1（第一次提交） 哈希值2（最新一次提交）：对比两个提交之间的差异
等于
git diff 哈希值1（第一次提交） HEAD（最新一次提交）
git diff HEAD~ HEAD
上述命令中的”HEAD”代表最新的提交，上述命令中的”HEAD~”代表最新提交的前一个提交，由于我们只有两个提交，所以，”HEAD”代表最新的提交（即 aafbaa8 ），”HEAD~ “代表最新提交的前一个提交（即 a63d5b2 ）
HEAD 表示当前分支的最新提交
HEAD~ 表示当前分支的最新提交的前一个提交（即最新的第二个提交，也就是最新提交的父提交）
HEAD~~ 表示当前分支的最新提交的前前提交（即最新的第三个提交，也就是最新提交的祖父提交）
HEAD~~~ 表示当前分支的最新提交的前前前提交（即最新的第四个提交，也就是最新提交的曾祖父提交）
相对提交名：
HEAD~~~等效于HEAD~3
HEAD~~等效于HEAD~2
HEAD~等效于HEAD~1
HEAD等效于HEAD~0

利用相对提交名获取对应的哈希码：
git rev-parse HEAD~ ：获取最新的第二个提交的哈希码
通过哈希码缩写获取完整的哈希码：
git rev-parse 3fd28a1
获取master分支的最新哈希码：
git rev-parse master

git diff 3fd28a1..514641e：比较两次commit
等价于：
git diff 3fd28a1..
git diff 3fd28a1..HEAD


git diff test master：比较test和master两个分支最新提交的差异
等价于：
git diff 5ce6b00 dc2f5e2：两个分支最新一次提交的哈希码
等价于：
git diff test..master


git diff命令总结：
比较工作区和暂存区：
git diff

比较工作区和当前分支最新的提交，你可以把HEAD换成别的分支的名字，比如test分支，
"git diff test"表示比较当前工作区和test分支最新的提交之间的差异，
也可以把HEAD替换成任何一个commit的ID，表示比较当前工作区和对应提交之间的差异：
git diff HEAD

比较暂存区和当前分支最新的提交：
git diff --cached

上述命令都是比较所有文件的差异，如果想要指定文件，可以使用"--"指定文件的路径，文件路径可以有多个，用空格隔开。
只比较工作区和暂存区中file1文件的差异：
git diff -- file1
git diff -- ./file1

只比较工作区和暂存区中file1以及file2文件的差异：
git diff -- file1 file2

只比较工作区和暂存区中dir1/d1/f1文件的差异：
git diff -- dir1/d1/f1

只比较工作区和暂存区中dir1目录中所有文件的差异：
git diff -- dir1/

只比较工作区和当前分支最新的提交中file1文件的差异，HEAD可以替换成分支名或者commitID：
git diff HEAD -- ./file1

只比较工作区和testbranch分支最新的提交中file1文件的差异：
git diff testbranch -- ./file1

比较暂存区和testbranch分支最新的提交：
git diff --cached testbranch

只比较暂存区和testbranch分支最新的提交中file1文件的差异：
git diff --cached testbranch --./file1

比较当前分支中最新的两个提交之间的差异：
git diff HEAD~ HEAD

比较当前分支中最新的两个提交中的file1文件的差异：
git diff HEAD~ HEAD -- file1

比较两个commit之间的差异：
git diff commitID1 commitID2

同上，比较两个commit之间的差异，两个命令等效：
git diff commitID1..commitID2

比较两个分支上最新提交之间的差异：
git diff branch1 branch2

同上，比较两个分支上最新提交之间的差异，两个命令等效：
git diff branch1..branch2


# 撤销暂存区变更
将暂存区的变更都撤销，将最近提交中的内容覆盖到暂存区
git reset HEAD
等价于
git reset -- mixed HEAD

从暂存区去除file2的变更
git reset HEAD -- file2

将工作区和暂存区的变更都撤销，将所有文件都恢复到最新一次提交的状态
git reset --hard HEAD

将HEAD指针指向commitID对应的提交，并且将对应提交中的内容同步到工作区，
HEAD指针、暂存区，以及工作区全部回到了指定提交时的状态，由于HEAD指针的指向也发生了变化，
所以当前分支的最新提交也会变成commitID对应的提交。
git reset --hard commitID

将HEAD指针指向commitID对应的提交，并且将对应提交中的内容同步到暂存区
HEAD指针以及暂存区中的内容都发生了变化，但是不会影响工作区，
所以当前分支的最新提交会变成commitID对应的提交，对应提交的状态会同步到暂存区，但是工作区中的内容或者变更不受影响。
git reset --mixed commitID

此命令只将HEAD指针指向commitID对应的提交，但是不会操作暂存区和工作区，
也就是说，当前分支中的最新提交会变成commitID对应的提交，工作区和暂存区中的内容或者变更不会受到任何影响。
git reset --soft commitID


	     工作区	   索引	  HEAD
--soft	  否	    否	   是
--mixed	  否	    是	   是
--hard	  是	    是	   是

# 撤销工作区变更
将工作区的f2文件更改撤销到最新一次f2提交的状态（没有add到暂存区）或f2暂存区的状态（add到了暂存区，并且又修改了工作区）
git checkout -- f2
一次性地将所有工作区的变更都撤销，可以在仓库的根目录执行
git checkout -- ./*

首先要注意，如果提交已经推送到远程仓库，操作这些提交时需谨慎。
撤销已经添加到暂存区中的修改，即让暂存区与最近的提交保持一致，可以使用如下命令，如下三条命令等效
git reset
git reset HEAD
git reset --mixed HEAD

也可以针对某些文件撤销暂存区中的修改，命令如下
git reset HEAD -- file1 file2

撤销所有暂存区和工作区中的所有变更
git reset --hard HEAD

回退到指定的提交
git reset --hard commitID

你已经将部分提交暂存到了暂存区，然后继续在工作区工作，工作区产生了新的变更，但是这些新变更没有添加到暂存区，
此时你创建了提交，刚刚创建完提交你就后悔了，你想要的回到提交创建前一刻的状态，可以使用如下命令
git reset --soft HEAD~

使用如下命令可以撤销工作区中file1文件的相关变更，可以细分为两种情况
git checkout -- file1
情况一：你先修改了file1，并且暂存了，然后又修改了file1，在工作区产生了新的变更，此时执行上述命令，
会将工作区中最新的变更撤销，工作区中的file1将会变成暂存区中file1的状态。

情况二：你修改了file1，暂存区中没有file1相关的变更，此时执行上述命令，会将工作区中最新的变更撤销，
工作区中的file1将会变成最近一次提交中file1的状态。


将A分支合并到当前分支。
git merge A

将A分支合并到当前分支，但是明确指定不使用”Fast-forward”的模式进行合并，
 “–no-ff”中的”ff”表示 “Fast-forward”，即使合并条件满足”Fast-forward”模式，
 也不使用快进的方式进行合并，而是使用创建合并提交的方式进行合并。
git merge --no-ff A

将A分支合并到当前分支，但是只有在符合”Fast-forward”模式的前提下才能合并成功，
在不符合”Fast-forward”模式的前提下，合并操作会自动终止，
换句话说就是，当能使用”Fast-forward”模式合并时，合并正常执行，当不能使用”Fast-forward”模式合并时，则不进行合并。
git merge --ff-only A

将A分支合并到当前分支，但是没有编辑默认注释的机会，也就是说，
在创建合并提交之前不会调用编辑器（上文的示例中会默认调用vim编辑器，以便使用者能够有机会编辑默认的注释信息），
让合并提交直接使用默认生成的注释，默认注释为“Merge branch ‘BranchName’”
git merge --no-edit A

将A分支合并到当前分支，并且使用-m参数指定合并提交对应的注释信息。
git merge A --no-ff -m "merge A into master,test merge message"

有冲突的情况下：
1.放弃合并：
git merge --abort
2.或者解决冲突：
查看并编辑产生冲突的文件：vim testfile
然后重新将文件保存到暂存区，提交到最新
git add testfile
git status //显示冲突已经解决
git commit -m ""

在没有冲突的情况下：
指定不自动创建提交，而是手动的创建提交，我们只需要借助“--no-commit”参数即可，示例如下
git merge --no-commit new

在完成合并操作后，删除new分支(需要切换到其他分支才能完成删除操作)：
git branch -d new
git branch -a

在test分支没有合并其它分支时，-d删除test分支会报错
此时可以使用-D参数强制删除：
git branch -D new

常用操作：
将暂存操作和提交操作一次性完成（省去手动执行git add的操作）
git commit -am "second commit"
如果你的工作区中存在完全新创建的文件（从未被git跟踪过，刚刚从工作区中新建出来），
那么"git commit -am"命令并不会将新建的文件添加到暂存区。

删除文件并将该变更自动提交到暂存区（省略手动执行git add命令的步骤）：
git rm testfile1
git status查看时，发现文件在文件系统中已经删除，并且更改已经提交到暂存区中

重命名文件并将该变更自动提交到暂存区（省略手动执行git add命令的步骤）：
git mv testfile1 tf1

总结：
省略“git add”操作，自动完成暂存并创建提交，换句话说就是，直接将工作区中的所有变更创建成一个提交，
注意：完全新建没有被git跟踪过的文件不会自动暂存。
git commit -am "注释"

删除testfile文件，并自动将变更暂存，效果相当于在文件系统中删除testfile，然后手动暂存。
git rm testfile

将testfile重命名成tf，并自动将变更暂存，效果相当于在文件系统中重命名了testfile，然后手动暂存。
git mv testfile tf

本地仓库中执行“git remote -v”命令，即可看到当前本地仓库对应的远程仓库
git remote -v

将本地的内容推送到远程origin仓库中，推送的本地分支名是master，远程分支名也是master，
没错，“master:master”中冒号左边的master代表你要推送的本地master分支，冒号右边的master代表推送到远程仓库中的master分支 
git push origin master:master

当本地分支和远程仓库的分支名字一样时，上面命令可以简化为
git push

将本地的master分支推送到远程origin仓库的m1分支中，当远程仓库没有m1分支时，通过此命令会自动创建
git push origin master:m1

在推送本地new分支到远程仓库的同时，直接将本地new分支的上游分支设置为远程仓库中的new分支
git push --set-upstream origin new:new
等价于
git push -u origin new:new（跟git版本有关，2.0后可以简写）

推送本地分支到远程分支的命令我们已经使用过，如下：
git push origin new:new

由于推送的本地分支和对应的远程分支同名，所以上述命令也可以简写为：
git push origin new
当执行完上述命令后，本地new分支已经推送到了远程仓库中。

这时我们再执行第二步，手动的将本地new分支的上游分支设置为远程origin仓库中的new分支，命令如下：
git branch new --set-upstream-to=origin/new
上述命令表示将本地的new分支的上游分支设置为“origin/new”分支，我们也可以使用短选项“-u”代替长选项“–set-upstream-to=”,命令如下：
git branch new -u origin/new

上述命令中的本地分支和远程分支的顺序也可以调换，如下命令与上述命令效果相同
git branch -u origin/new new
记忆小技巧：“-u”选项后面指定远程分支名即可，本地分支和远程分支顺序无所谓。

也可以省略上述命令中的本地分支名称，当没有指定本地分支名称时，表示默认设置当前分支的上游分支，
比如，当前我处于a分支，那么当我执行如下命令时，就表示将本地a分支的上游分支设置为“origin/new”
git branch -u origin/new

除了显示出了本地的master分支和new分支，还显示出了一些以“remotes/origin/”开头的分支
git branch -avv

为本地仓库添加远程仓库：
git remote add origin git@github.com:zsythink/test1.git

当本地分支与上游分支同名时，push所有分支的更新到对应的远程分支
git push --all

获取远程仓库的更新到本地，但是不会更新本地分支中的代码
git fetch

将remote仓库的A分支pull到本地当前所在分支，如果你想要pull到本地的A分支，需要先checkout到本地A分支中
git pull remote branchA

将remote仓库的A分支pull到本地的B分支，在成功的将远程A分支pull到本地B分支后
（如果远程A到本地B的pull操作失败了，后面的操作不会执行），再将远程A分支pull到本地的当前所在的分支。
git pull remote branchA:branchB

当本地分支与上游分支同名时，对当前分支执行pull操作，对其他分支执行fetch操作，具体的差异主要取决于对应的远程分支有没有更新。
git pull


git pull命令的含义解释：
作用是，pull当前分支的同名上游分支，并且将其他分支的同名上游分支的更新fetch到本地，这样说不容易理解，我们举个例子，
比如，当前仓库有A、B、C三个分支，这3个分支都已经checkout到本地的仓库当中了，假设当前我们处于本地的A分支中，那么，
当我们执行“git pull”命令时，会有几种情况：
情况1：当我们处于A分支，A分支的同名上游分支没有更新，但是B分支或者C分支的同名上游分支有更新，执行“git pull”命令，
你会看到git对B分支或者C分支执行了fetch操作，但是只是fetch，没有对应的自动merge操作，当然，如果B分支和C分支的同名上游分支都有更新，就都会fetch。
情况2：当我们处于A分支，A分支的同名上游分支有更新，B分支或者C分支的同名上游分支也有更新，执行“git pull”命令，
你会看到git对A分支执行了pull操作（即fetch+merge），对B分支或C分支执行了fetch操作，当然，如果B分支和C分支的同名上游分支都有更新，就都会fetch。
总结一下就是，当本地分支与上游分支同名时，“git pull”命令会对当前分支执行pull操作，对其他分支执行fetch操作，
具体的差异主要取决于对应的远程分支有没有更新。